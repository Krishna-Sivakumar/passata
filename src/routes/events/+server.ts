import type { RequestHandler } from '@sveltejs/kit';
import sqlite3 from "better-sqlite3";
import { writable, type Writable } from 'svelte/store';
import {produce} from 'sveltekit-sse';
import type { LogEvent, TimestampedLogs } from '$lib/structs';
import {setupDB, insertLog} from "$lib/db"

const eventObserver: Map<string, Writable<number>> = new Map();

// used to measure the RTT for corrections
export const GET: RequestHandler = async () => {
    return new Response(`${Date.now()}`);
}

export const POST: RequestHandler = async ({ url }) => {
    let last_timestamp = -1;
    return produce(async function start({emit}) {
        const token = url.searchParams.get("token");
        const connection = url.searchParams.get("connectionToken")
        if (token && connection) {
            console.log("sent updates to", token)
            let store = eventObserver.get(token);
            if (!store) {
                eventObserver.set(token, writable(0));
                store = eventObserver.get(token);
            }

            // each SSE stream subscribes to the event observer to check if there have been writes to a particular token.
            store?.subscribe(() => {
                let db = setupDB();
                // if this master client has no logs, send them all out right now. Else send only stuff generated by other master clients.
                let logs: {log:string, timestamp: number}[];
                if (last_timestamp == -1) {
                    logs = db.prepare("SELECT log, timestamp FROM log WHERE token = ? AND timestamp > ? ORDER BY timestamp DESC").all(token, last_timestamp) as {log: string, timestamp: number}[];
                } else {
                    logs = db.prepare("SELECT log, timestamp FROM log WHERE token = ? AND timestamp > ? AND connection <> ? ORDER BY timestamp DESC").all(token, last_timestamp, connection) as {log: string, timestamp: number}[];
                }
                if (logs.length > 0) {
                    last_timestamp = logs[0].timestamp;
                }
                let response: TimestampedLogs = {
                    logs: logs.map(item => JSON.parse(item.log) as LogEvent),
                    responseTimestamp: Date.now(),
                }
                emit('update', JSON.stringify(response));
            })
        }
    });
}

// we're using the PUT method since the POST method is reserved for Server-Sent-Event responses
export const PUT: RequestHandler = async ({ request, url }) => {
    let event: LogEvent = await request.json();
    event.realTimestamp = Date.now(); // every timestamp is pegged to the server's time
    let token = url.searchParams.get("token")
    let connection = url.searchParams.get("connectionToken")
    if (token && connection) {
        insertLog(token, event, connection)
        let store = eventObserver.get(token);
        if (!store) {
            eventObserver.set(token, writable(0));
            store = eventObserver.get(token);
        }
        // notifying subscribers by bumping the store's value
        store?.update((oldValue) => {
            return oldValue + 1;
        })

        return new Response(JSON.stringify(event), {
            headers: {
                "Content-Type": "text/event-stream",
            },
        });
    } else {
        throw new Error("token invalid.")
    }
}
