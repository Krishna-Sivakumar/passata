import type { RequestHandler } from '@sveltejs/kit';
import sqlite3 from "better-sqlite3";
import { writable, type Writable } from 'svelte/store';
import { produce } from 'sveltekit-sse';
import type { LogEvent, TimestampedLogs } from '$lib/structs';
import { setupDB, insertLog, fetchRows } from "$lib/db"

// used to measure the RTT for corrections
export const GET: RequestHandler = async () => {
    return new Response(`${Date.now()}`);
}

export const POST: RequestHandler = async ({ url }) => {
    let last_timestamp = -1;
    return produce(async function start({ emit }) {
        const token = url.searchParams.get("token");
        const connection = url.searchParams.get("connectionToken")
        if (token && connection) {
            // TODO client needs to attach the latest index of its log and ask for updates FROM THAT POINT ONWARDS
            setInterval(async () => {
                let db = await setupDB();
                // if this master client has no logs, send them all out right now. Else send only stuff generated by other master clients.
                let logs: { log: string, timestamp: number }[];
                if (last_timestamp == -1) {
                    logs = await fetchRows<{log: string, timestamp: number}>(db.prepare("SELECT log, timestamp FROM log WHERE token = ? AND timestamp > ? ORDER BY timestamp DESC"), [token, last_timestamp])
                } else {
                    logs = await fetchRows<{log: string, timestamp: number}>(db.prepare("SELECT log, timestamp FROM log WHERE token = ? AND timestamp > ? AND connection <> ? ORDER BY timestamp DESC"), [token, last_timestamp, connection])
                }
                if (logs.length > 0) {
                    last_timestamp = logs[0].timestamp;
                } else {
                    return;
                }
                console.log(`sending ${logs.length} logs to ${connection.slice(0, 10)}`)

                let response: TimestampedLogs = {
                    logs: logs.map(item => JSON.parse(item.log) as LogEvent),
                    responseTimestamp: Date.now(),
                }
                const { error } = emit('update', JSON.stringify(response));
                if (error) {
                    return;
                }
            }, 100)
        }
    });
}

// we're using the PUT method since the POST method is reserved for Server-Sent-Event responses
export const PUT: RequestHandler = async ({ request, url }) => {
    // TODO replace token with connectionToken and remove references invovling just token
    let event: LogEvent = await request.json();
    event.realTimestamp = Date.now(); // every timestamp is pegged to the server's time
    let token = url.searchParams.get("token")
    let connection = url.searchParams.get("connectionToken")
    if (token && connection) {
        insertLog(token, event, connection)
        return new Response(JSON.stringify(event), {
            headers: {
                "Content-Type": "text/event-stream",
            },
        });
    } else {
        throw new Error("token invalid.")
    }
}
